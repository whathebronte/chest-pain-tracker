<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Chest Pain Tracker</title>
  <meta name="description" content="A simple tracker for chest pain episodes with export + shareable report." />
  <style>
    :root{
      --bg:#0b0c10;
      --card:#12141b;
      --card2:#0f1117;
      --text:#f3f4f6;
      --muted:#a7acb8;
      --line:#252a36;
      --good:#1fda8a;
      --warn:#ffcc66;
      --bad:#ff6b6b;
      --accent:#7aa2ff;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --r:16px;
      --pad:16px;
      --pad2:22px;
      --w: 980px;
      font-synthesis-weight:none;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      background: radial-gradient(900px 600px at 30% -10%, rgba(122,162,255,.18), transparent 60%),
                  radial-gradient(900px 600px at 80% 10%, rgba(31,218,138,.12), transparent 60%),
                  var(--bg);
      color:var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Apple Color Emoji","Segoe UI Emoji";
      line-height:1.35;
    }
    a{color:inherit}
    .wrap{max-width:var(--w); margin:0 auto; padding:18px 14px 70px;}
    .topbar{
      position:sticky; top:0; z-index:20;
      backdrop-filter: blur(10px);
      background: rgba(11,12,16,.6);
      border-bottom:1px solid rgba(37,42,54,.7);
    }
    .topbar-inner{max-width:var(--w); margin:0 auto; padding:12px 14px; display:flex; gap:10px; align-items:center;}
    .brand{
      display:flex; gap:10px; align-items:center; min-width: 220px;
    }
    .logo{
      width:34px; height:34px; border-radius:12px;
      background: linear-gradient(135deg, rgba(122,162,255,.9), rgba(31,218,138,.9));
      box-shadow: var(--shadow);
    }
    .title{
      display:flex; flex-direction:column;
    }
    .title b{font-size:14px; letter-spacing:.2px}
    .title span{font-size:12px; color:var(--muted)}
    .nav{
      display:flex; gap:8px; flex-wrap:wrap; align-items:center;
    }
    button{
      appearance:none; border:1px solid var(--line);
      background: rgba(18,20,27,.85);
      color:var(--text);
      padding:9px 12px;
      border-radius:12px;
      cursor:pointer;
      transition:.12s transform, .12s background, .12s border-color;
      font-weight:600;
      font-size:13px;
    }
    button:hover{transform: translateY(-1px); border-color: rgba(122,162,255,.45)}
    button:active{transform: translateY(0px)}
    button.primary{
      background: linear-gradient(135deg, rgba(122,162,255,.95), rgba(122,162,255,.65));
      border-color: rgba(122,162,255,.8);
      color:#071021;
    }
    button.danger{
      background: rgba(255,107,107,.12);
      border-color: rgba(255,107,107,.45);
      color: var(--text);
    }
    button.ghost{
      background: transparent;
    }
    .spacer{flex:1}
    .pill{
      display:flex; align-items:center; gap:8px;
      padding:7px 10px;
      border:1px solid var(--line);
      border-radius:999px;
      background: rgba(18,20,27,.6);
      font-size:12px;
      color:var(--muted);
      white-space:nowrap;
    }
    .dot{width:10px;height:10px;border-radius:999px;background:var(--muted)}
    .pill.good .dot{background:var(--good)}
    .pill.warn .dot{background:var(--warn)}
    .pill.bad .dot{background:var(--bad)}
    .pill span{color:var(--text); font-weight:700; font-size:12px}
    .grid{
      margin-top:16px;
      display:grid;
      grid-template-columns: 1.1fr .9fr;
      gap:14px;
    }
    @media (max-width: 920px){
      .grid{grid-template-columns:1fr}
      .brand{min-width:auto}
    }
    .card{
      background: linear-gradient(180deg, rgba(18,20,27,.92), rgba(15,17,23,.92));
      border:1px solid rgba(37,42,54,.9);
      border-radius: var(--r);
      box-shadow: var(--shadow);
      padding: var(--pad2);
    }
    .card h2{margin:0 0 8px 0; font-size:16px}
    .card p{margin:0; color:var(--muted)}
    .row{display:flex; gap:10px; flex-wrap:wrap; align-items:center}
    .kpi{
      display:grid;
      grid-template-columns: repeat(3, 1fr);
      gap:10px;
      margin-top:12px;
    }
    @media (max-width: 600px){ .kpi{grid-template-columns:1fr} }
    .k{
      border:1px solid rgba(37,42,54,.9);
      background: rgba(18,20,27,.5);
      border-radius:14px;
      padding:12px;
    }
    .k b{display:block; font-size:18px}
    .k span{font-size:12px; color:var(--muted)}
    .banner{
      margin-top:12px;
      border-radius:14px;
      border:1px solid rgba(255,204,102,.35);
      background: rgba(255,204,102,.08);
      padding:12px;
      color: var(--text);
      font-size:13px;
    }
    .banner b{display:block; margin-bottom:6px}
    .muted{color:var(--muted)}
    .view{display:none}
    .view.active{display:block}
    .section-title{display:flex; align-items:center; justify-content:space-between; gap:10px; margin-bottom:10px}
    .section-title h2{margin:0; font-size:16px}
    .form{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:12px;
    }
    @media (max-width: 820px){ .form{grid-template-columns:1fr} }
    label{display:block; font-size:12px; color:var(--muted); margin-bottom:6px}
    input, select, textarea{
      width:100%;
      border:1px solid rgba(37,42,54,.9);
      border-radius:12px;
      background: rgba(11,12,16,.5);
      color:var(--text);
      padding:10px 11px;
      font-size:14px;
      outline:none;
    }
    textarea{min-height:92px; resize:vertical}
    input:focus, select:focus, textarea:focus{border-color: rgba(122,162,255,.65)}
    .chips{
      display:flex; flex-wrap:wrap; gap:8px;
    }
    .chip{
      border:1px solid rgba(37,42,54,.9);
      background: rgba(18,20,27,.55);
      color: var(--text);
      padding:8px 10px;
      border-radius:999px;
      font-size:13px;
      cursor:pointer;
      user-select:none;
      transition:.12s transform, .12s border-color, .12s background;
    }
    .chip:hover{transform:translateY(-1px); border-color: rgba(122,162,255,.45)}
    .chip.selected{
      border-color: rgba(31,218,138,.7);
      background: rgba(31,218,138,.12);
    }
    .chip.disabled{opacity:.5; pointer-events:none}
    .inline{
      display:flex; gap:10px; flex-wrap:wrap; align-items:center;
    }
    .inline > *{flex: 1 1 180px}
    .help{
      font-size:12px;
      color:var(--muted);
      margin-top:6px;
    }
    .subcard{
      margin-top:12px;
      padding:14px;
      border-radius:14px;
      border:1px solid rgba(37,42,54,.9);
      background: rgba(18,20,27,.35);
    }
    .subcard h3{margin:0 0 10px 0; font-size:14px}
    .actions{
      display:flex; gap:10px; flex-wrap:wrap; margin-top:14px;
      align-items:center;
    }
    .table{
      width:100%;
      border-collapse: collapse;
      margin-top:10px;
      font-size:13px;
    }
    .table th, .table td{
      border-bottom:1px solid rgba(37,42,54,.8);
      padding:10px 8px;
      text-align:left;
      vertical-align:top;
    }
    .table th{color:var(--muted); font-size:12px; font-weight:700}
    .list{
      display:flex;
      flex-direction:column;
      gap:10px;
      margin-top:10px;
    }
    .item{
      border:1px solid rgba(37,42,54,.9);
      border-radius:14px;
      background: rgba(18,20,27,.4);
      padding:12px;
      display:flex;
      justify-content:space-between;
      gap:12px;
      cursor:pointer;
      transition: .12s border-color, .12s transform;
    }
    .item:hover{transform:translateY(-1px); border-color: rgba(122,162,255,.45)}
    .item b{display:block; font-size:13px}
    .item span{display:block; font-size:12px; color:var(--muted)}
    .item .right{
      text-align:right;
      min-width:90px;
      display:flex;
      flex-direction:column;
      justify-content:center;
    }
    .tag{
      display:inline-flex;
      align-items:center;
      gap:6px;
      border:1px solid rgba(37,42,54,.9);
      background: rgba(11,12,16,.4);
      border-radius:999px;
      padding:4px 8px;
      color:var(--muted);
      font-size:12px;
      margin-right:6px;
      margin-top:6px;
    }
    .hr{height:1px;background:rgba(37,42,54,.9);margin:14px 0}
    .small{font-size:12px;color:var(--muted)}
    .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;}
    .hide{display:none !important;}

    /* Print view */
    @media print{
      body{background:#fff;color:#111}
      .topbar, .no-print{display:none !important}
      .wrap{max-width:100%;padding:0}
      .card{box-shadow:none;border:0;border-radius:0;background:#fff;padding:0}
      .subcard{border:1px solid #ddd;background:#fff}
      .table th, .table td{border-bottom:1px solid #ddd}
      .muted, .small{color:#444}
      a{color:#111;text-decoration:none}
    }
  </style>
</head>

<body>
  <div class="topbar no-print">
    <div class="topbar-inner">
      <div class="brand">
        <div class="logo" aria-hidden="true"></div>
        <div class="title">
          <b>Chest Pain Tracker</b>
          <span>Log episodes • Export & share reports</span>
        </div>
      </div>

      <div class="nav">
        <button id="navHome" class="ghost">Home</button>
        <button id="navLog" class="primary">Log now</button>
        <button id="navHistory">History</button>
        <button id="navExport">Export</button>
        <button id="navSettings">Settings</button>
      </div>

      <div class="spacer"></div>

      <div id="syncPill" class="pill warn" title="Sync status">
        <div class="dot"></div>
        <span id="syncText">Starting…</span>
      </div>
    </div>
  </div>

  <div class="wrap">
    <!-- HOME -->
    <div id="viewHome" class="view active">
      <div class="grid">
        <div class="card">
          <div class="section-title">
            <h2>Quick actions</h2>
            <div class="small">Private by default. Share only via a secret link.</div>
          </div>

          <div class="row">
            <button class="primary" id="homeLogNow">Log chest pain now</button>
            <button id="homeHistory">View history</button>
            <button id="homeExport">Export</button>
          </div>

          <div id="resumeDraftBox" class="subcard hide">
            <h3>Resume draft</h3>
            <div class="muted" id="draftSummary"></div>
            <div class="actions">
              <button class="primary" id="resumeDraftBtn">Resume draft</button>
              <button class="danger" id="discardDraftBtn">Discard draft</button>
            </div>
          </div>

          <div class="banner">
            <b>Safety note</b>
            If chest pain is severe, new, or with trouble breathing, fainting, heavy sweating, or worsening symptoms, seek urgent medical care.
          </div>
        </div>

        <div class="card">
          <div class="section-title">
            <h2>At a glance</h2>
          </div>

          <div class="kpi">
            <div class="k">
              <b id="kpi7d">0</b>
              <span>Episodes (last 7 days)</span>
            </div>
            <div class="k">
              <b id="kpi30d">0</b>
              <span>Episodes (last 30 days)</span>
            </div>
            <div class="k">
              <b id="kpiLast">—</b>
              <span>Last severity</span>
            </div>
          </div>

          <div class="subcard">
            <h3>Most common onset activity (30 days)</h3>
            <div class="muted" id="kpiCommonActivity">—</div>
          </div>

          <div class="subcard">
            <h3>Backup & device</h3>
            <div class="small">This device uses a private device ID in Firebase (invisible sign-in). Your public share link is optional and revocable.</div>
            <div class="hr"></div>
            <div class="small">Device ID (Firebase UID): <span id="uidText" class="mono">—</span></div>
          </div>
        </div>
      </div>
    </div>

    <!-- LOG -->
    <div id="viewLog" class="view">
      <div class="card">
        <div class="section-title">
          <h2 id="logTitle">Log an episode</h2>
          <div class="small" id="logSubtitle">Auto-saved locally while you fill this in. Press “Save log” when done.</div>
        </div>

        <div class="form">
          <div>
            <label>Start time</label>
            <input id="startAt" type="datetime-local" />
            <div class="help">Defaults to now. Adjust if needed.</div>
          </div>

          <div>
            <label>Ongoing?</label>
            <div class="inline">
              <select id="ongoing">
                <option value="true">Yes (still happening)</option>
                <option value="false">No (ended)</option>
              </select>
              <div id="endAtWrap" class="hide">
                <label style="margin:0 0 6px 0">End time</label>
                <input id="endAt" type="datetime-local" />
              </div>
            </div>
            <div id="durationChipsWrap" class="help hide">Or choose duration:</div>
            <div id="durationChips" class="chips hide" aria-label="Duration quick picks"></div>
          </div>

          <div>
            <label>Severity (0–10)</label>
            <input id="severity" type="range" min="0" max="10" step="1" />
            <div class="help">Selected: <b id="severityVal">5</b></div>
          </div>

          <div>
            <label>Pain type</label>
            <div id="painTypeChips" class="chips"></div>
          </div>

          <div>
            <label>Location</label>
            <div id="locationChips" class="chips"></div>
          </div>

          <div>
            <label>Activity at onset</label>
            <div id="activityChips" class="chips"></div>
          </div>

          <div>
            <label>Relief</label>
            <div id="reliefChips" class="chips"></div>
          </div>

          <div>
            <label>Associated symptoms</label>
            <div id="symptomChips" class="chips"></div>
            <div class="help">Tip: choose “None” if there were no other symptoms.</div>
          </div>

          <div style="grid-column: 1 / -1;">
            <label>Notes (optional)</label>
            <textarea id="notes" maxlength="500" placeholder="Anything else? (short is fine)"></textarea>
            <div class="help"><span id="notesCount">0</span>/500</div>
          </div>
        </div>

        <div class="subcard">
          <h3>Optional details</h3>
          <div class="form">
            <div>
              <label>Heart rate (bpm)</label>
              <input id="v_hr" type="number" inputmode="numeric" placeholder="e.g. 92" />
            </div>
            <div>
              <label>SpO₂ (%)</label>
              <input id="v_spo2" type="number" inputmode="numeric" placeholder="e.g. 98" />
            </div>
            <div>
              <label>Blood pressure (systolic)</label>
              <input id="v_bpsys" type="number" inputmode="numeric" placeholder="e.g. 130" />
            </div>
            <div>
              <label>Blood pressure (diastolic)</label>
              <input id="v_bpdia" type="number" inputmode="numeric" placeholder="e.g. 80" />
            </div>

            <div style="grid-column:1 / -1;">
              <label>Meds taken (optional)</label>
              <div class="small muted">Add rows like “Antacid”, “Nitro”, “Painkiller”.</div>
              <div id="medsList" class="list"></div>
              <div class="actions">
                <button id="addMedBtn">+ Add medication</button>
              </div>
            </div>
          </div>
        </div>

        <div class="actions no-print">
          <button class="primary" id="saveLogBtn">Save log</button>
          <button id="newDraftBtn">Start new draft</button>
          <button class="danger" id="discardDraftBtn2">Discard draft</button>
          <div class="spacer"></div>
          <button id="backHomeBtn">Back to Home</button>
        </div>

        <div class="hr"></div>
        <div class="small">
          <b>How this saves:</b> Your inputs are auto-saved locally while you fill this in. “Save log” adds it to History and syncs to Firebase.
        </div>
      </div>
    </div>

    <!-- HISTORY -->
    <div id="viewHistory" class="view">
      <div class="card">
        <div class="section-title">
          <h2>History</h2>
          <div class="inline no-print" style="max-width:520px">
            <select id="historyRange">
              <option value="7">Last 7 days</option>
              <option value="30" selected>Last 30 days</option>
              <option value="90">Last 90 days</option>
              <option value="365">Last 12 months</option>
              <option value="all">All time</option>
            </select>
            <select id="historySeverity">
              <option value="all">All severities</option>
              <option value="7+">7–10</option>
              <option value="4+">4–10</option>
              <option value="0-3">0–3</option>
            </select>
          </div>
        </div>

        <div class="small muted">Tap an item to edit. Edits auto-save locally and sync shortly after.</div>
        <div id="historyList" class="list"></div>
      </div>
    </div>

    <!-- EXPORT -->
    <div id="viewExport" class="view">
      <div class="card">
        <div class="section-title">
          <h2>Export</h2>
          <div class="inline no-print" style="max-width:520px">
            <select id="exportRange">
              <option value="7">Last 7 days</option>
              <option value="30" selected>Last 30 days</option>
              <option value="90">Last 90 days</option>
              <option value="365">Last 12 months</option>
              <option value="all">All time</option>
            </select>
            <button id="refreshReportBtn">Refresh report</button>
          </div>
        </div>

        <div class="subcard no-print">
          <h3>Clinician summary (Print to PDF)</h3>
          <div class="small muted">Click “Print / Save PDF” to open the browser print dialog and save as PDF.</div>
          <div class="actions">
            <button class="primary" id="printBtn">Print / Save PDF</button>
            <button id="downloadCsvBtn">Download CSV</button>
            <button id="downloadJsonBtn">Download JSON</button>
          </div>
        </div>

        <div class="subcard no-print">
          <h3>Share a read-only report link</h3>
          <div class="small muted">
            One active link only. Anyone with the link can view this report snapshot. You can revoke it anytime.
          </div>
          <div class="actions">
            <button class="primary" id="createShareBtn">Create / Replace share link</button>
            <button id="copyShareBtn" class="hide">Copy share link</button>
            <button id="revokeShareBtn" class="danger hide">Revoke share link</button>
          </div>
          <div id="shareLinkBox" class="small mono hide" style="margin-top:10px; word-break:break-all;"></div>
        </div>

        <!-- Printable report content -->
        <div id="reportArea">
          <div class="section-title">
            <h2>Chest pain report</h2>
            <div class="small">Generated: <span id="reportGeneratedAt">—</span></div>
          </div>

          <div class="subcard">
            <h3>Summary</h3>
            <div id="reportSummary" class="muted"></div>
          </div>

          <div class="subcard">
            <h3>Episodes</h3>
            <table class="table" id="reportTable">
              <thead>
                <tr>
                  <th>Date/Time</th>
                  <th>Severity</th>
                  <th>Duration</th>
                  <th>Activity</th>
                  <th>Type/Location</th>
                  <th>Symptoms</th>
                  <th>Relief</th>
                  <th>Notes</th>
                </tr>
              </thead>
              <tbody id="reportTbody"></tbody>
            </table>
          </div>
        </div>

      </div>
    </div>

    <!-- SETTINGS -->
    <div id="viewSettings" class="view">
      <div class="card">
        <div class="section-title">
          <h2>Settings</h2>
          <div class="small muted">Private storage on this device + Firebase backup sync.</div>
        </div>

        <div class="subcard">
          <h3>Data controls</h3>
          <div class="actions">
            <button id="exportAllJsonBtn">Download ALL data (JSON)</button>
            <button id="exportAllCsvBtn">Download ALL data (CSV)</button>
          </div>
          <div class="hr"></div>
          <div class="actions">
            <button class="danger" id="clearAllBtn">Clear ALL data on this device + Firebase</button>
          </div>
          <div class="help">This cannot be undone.</div>
        </div>

        <div class="subcard">
          <h3>About</h3>
          <div class="small muted">
            This app helps track episodes for review and sharing with medical providers. It does not diagnose or replace medical advice.
          </div>
        </div>
      </div>
    </div>

    <!-- SHARE VIEW (public read-only) -->
    <div id="viewShare" class="view">
      <div class="card">
        <div class="section-title">
          <h2>Shared chest pain report</h2>
          <div class="small">Read-only</div>
        </div>

        <div class="subcard no-print">
          <div class="small muted">
            If you are viewing this from a doctor’s office, you can print or save as PDF.
          </div>
          <div class="actions">
            <button class="primary" id="sharePrintBtn">Print / Save PDF</button>
            <button id="shareDownloadCsvBtn">Download CSV</button>
            <button id="shareDownloadJsonBtn">Download JSON</button>
          </div>
        </div>

        <div id="shareReportArea">
          <div class="section-title">
            <h2>Chest pain report</h2>
            <div class="small">Generated: <span id="shareGeneratedAt">—</span></div>
          </div>

          <div class="subcard">
            <h3>Summary</h3>
            <div id="shareSummary" class="muted"></div>
          </div>

          <div class="subcard">
            <h3>Episodes</h3>
            <table class="table">
              <thead>
                <tr>
                  <th>Date/Time</th>
                  <th>Severity</th>
                  <th>Duration</th>
                  <th>Activity</th>
                  <th>Type/Location</th>
                  <th>Symptoms</th>
                  <th>Relief</th>
                  <th>Notes</th>
                </tr>
              </thead>
              <tbody id="shareTbody"></tbody>
            </table>
          </div>

          <div id="shareError" class="banner hide" style="border-color: rgba(255,107,107,.4); background: rgba(255,107,107,.10);">
            <b>Could not load shared report</b>
            <div class="small">The link may be invalid, revoked, or the report is unavailable.</div>
          </div>
        </div>

      </div>
    </div>

  </div>

<script type="module">
  /***********************
   * Firebase (CDN modules)
   ***********************/
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-app.js";
  import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-auth.js";
  import {
    getFirestore, doc, setDoc, getDoc, deleteDoc,
    collection, query, orderBy, where, getDocs, onSnapshot, serverTimestamp
  } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-firestore.js";

  const firebaseConfig = {
    apiKey: "AIzaSyAY9or2wznVWfjmcA7t8zmvP4tij4GV0Vc",
    authDomain: "chest-pain-tracker.firebaseapp.com",
    projectId: "chest-pain-tracker",
    storageBucket: "chest-pain-tracker.firebasestorage.app",
    messagingSenderId: "695419264328",
    appId: "1:695419264328:web:279b5091674d4497c1a77d"
  };

  const app = initializeApp(firebaseConfig);
  const auth = getAuth(app);
  const db = getFirestore(app);

  /***********************
   * Constants (chips)
   ***********************/
  const ENUMS = {
    painType: ["Pressure","Tightness","Sharp","Burning","Ache","Other"],
    location: ["Center","Left","Right","Upper abdomen","Other"],
    activity: ["Rest","Walking","Stairs","Exercise","After meal","Stress","Sleeping","Other"],
    relief: ["Rest","Breathing","Antacid","Nitro","Painkiller","None","Other"],
    symptoms: ["Shortness of breath","Sweating","Nausea","Dizziness","Palpitations","Radiation (arm/jaw/back)","None"],
    durationMins: [1,5,10,20,30,60,120]
  };

  /***********************
   * DOM helpers
   ***********************/
  const $ = (id) => document.getElementById(id);
  const show = (el) => el.classList.remove("hide");
  const hide = (el) => el.classList.add("hide");

  function setView(name){
    const views = ["Home","Log","History","Export","Settings","Share"];
    views.forEach(v => {
      const el = $("view"+v);
      if(!el) return;
      el.classList.toggle("active", v.toLowerCase() === name.toLowerCase());
    });
  }

  function setSync(status){
    const pill = $("syncPill");
    const text = $("syncText");
    pill.classList.remove("good","warn","bad");
    let cls="warn", label=status;
    if(status === "Synced") cls="good";
    if(status.startsWith("Sync error")) cls="bad";
    if(status.startsWith("Offline")) cls="warn";
    if(status.startsWith("Starting")) cls="warn";
    if(status.startsWith("Saved locally")) cls="warn";
    if(status.startsWith("Syncing")) cls="warn";
    pill.classList.add(cls);
    text.textContent = label;
  }

  function nowLocalDatetimeInputValue(){
    const d = new Date();
    const pad = (n)=>String(n).padStart(2,"0");
    const yyyy = d.getFullYear();
    const mm = pad(d.getMonth()+1);
    const dd = pad(d.getDate());
    const hh = pad(d.getHours());
    const mi = pad(d.getMinutes());
    return `${yyyy}-${mm}-${dd}T${hh}:${mi}`;
  }

  function parseDTLocal(val){
    // input datetime-local returns "YYYY-MM-DDTHH:MM"
    if(!val) return null;
    const d = new Date(val);
    return isNaN(d.getTime()) ? null : d;
  }

  function fmtDateTime(d){
    if(!d) return "—";
    const dt = (d instanceof Date) ? d : new Date(d);
    if(isNaN(dt.getTime())) return "—";
    return dt.toLocaleString(undefined, { year:"numeric", month:"short", day:"2-digit", hour:"2-digit", minute:"2-digit" });
  }

  function minutesBetween(a,b){
    if(!a || !b) return null;
    const ms = b.getTime() - a.getTime();
    if(!isFinite(ms)) return null;
    return Math.max(0, Math.round(ms/60000));
  }

  function durationLabel(startAt, endAt, ongoing){
    if(ongoing) return "Ongoing";
    const a = startAt ? new Date(startAt) : null;
    const b = endAt ? new Date(endAt) : null;
    const mins = minutesBetween(a,b);
    if(mins == null) return "—";
    if(mins < 60) return `${mins} min`;
    const h = Math.floor(mins/60);
    const m = mins % 60;
    return m ? `${h}h ${m}m` : `${h}h`;
  }

  function safeArray(a){ return Array.isArray(a) ? a : []; }

  /***********************
   * IndexedDB (local-first)
   ***********************/
  const IDB_NAME = "cpt_db_v1";
  const IDB_VER = 1;

  function idbOpen(){
    return new Promise((resolve,reject)=>{
      const req = indexedDB.open(IDB_NAME, IDB_VER);
      req.onupgradeneeded = () => {
        const db = req.result;
        if(!db.objectStoreNames.contains("episodes")){
          const store = db.createObjectStore("episodes", { keyPath: "id" });
          store.createIndex("startAt", "startAt", { unique:false });
        }
        if(!db.objectStoreNames.contains("meta")){
          db.createObjectStore("meta", { keyPath: "key" });
        }
      };
      req.onsuccess = () => resolve(req.result);
      req.onerror = () => reject(req.error);
    });
  }

  async function idbGet(storeName, key){
    const db = await idbOpen();
    return new Promise((resolve,reject)=>{
      const tx = db.transaction(storeName, "readonly");
      const store = tx.objectStore(storeName);
      const req = store.get(key);
      req.onsuccess = ()=> resolve(req.result);
      req.onerror = ()=> reject(req.error);
    });
  }

  async function idbPut(storeName, value){
    const db = await idbOpen();
    return new Promise((resolve,reject)=>{
      const tx = db.transaction(storeName, "readwrite");
      tx.objectStore(storeName).put(value);
      tx.oncomplete = ()=> resolve(true);
      tx.onerror = ()=> reject(tx.error);
    });
  }

  async function idbDelete(storeName, key){
    const db = await idbOpen();
    return new Promise((resolve,reject)=>{
      const tx = db.transaction(storeName, "readwrite");
      tx.objectStore(storeName).delete(key);
      tx.oncomplete = ()=> resolve(true);
      tx.onerror = ()=> reject(tx.error);
    });
  }

  async function idbGetAllEpisodes(){
    const db = await idbOpen();
    return new Promise((resolve,reject)=>{
      const tx = db.transaction("episodes","readonly");
      const store = tx.objectStore("episodes");
      const req = store.getAll();
      req.onsuccess = ()=> resolve(req.result || []);
      req.onerror = ()=> reject(req.error);
    });
  }

  /***********************
   * App state
   ***********************/
  let UID = null;
  let EPISODES = [];        // local cache
  let CURRENT_EDIT_ID = null;
  let DRAFT = null;         // current draft object
  let SHARE_TOKEN = null;   // one active share link token
  let lastWriteError = null;
  let firestoreUnsub = null;

  const DRAFT_KEY = "draft";
  const SHARE_KEY = "share_token";

  /***********************
   * Draft + Auto-save (debounced local)
   ***********************/
  let draftSaveTimer = null;

  function scheduleDraftSave(){
    if(draftSaveTimer) clearTimeout(draftSaveTimer);
    draftSaveTimer = setTimeout(async ()=>{
      try{
        await idbPut("meta", { key: DRAFT_KEY, value: DRAFT });
        setSync(navigator.onLine ? "Saved locally" : "Offline (saved locally)");
        renderDraftResume();
      }catch(e){
        console.error("Draft save failed", e);
      }
    }, 450);
  }

  /***********************
   * Render chips
   ***********************/
  function renderSingleSelectChips(containerId, options, getVal, setVal){
    const el = $(containerId);
    el.innerHTML = "";
    options.forEach(opt=>{
      const c = document.createElement("div");
      c.className = "chip";
      c.textContent = opt;
      c.onclick = ()=>{
        setVal(opt);
        updateChipSelection(el, getVal(), false);
        onFormChange();
      };
      el.appendChild(c);
    });
    updateChipSelection(el, getVal(), false);
  }

  function renderMultiSelectChips(containerId, options, getArr, setArr){
    const el = $(containerId);
    el.innerHTML = "";
    options.forEach(opt=>{
      const c = document.createElement("div");
      c.className = "chip";
      c.textContent = opt;
      c.onclick = ()=>{
        const arr = new Set(getArr());
        if(opt === "None"){
          // Selecting None clears others
          if(arr.has("None")) arr.delete("None"); else { arr.clear(); arr.add("None"); }
        } else {
          arr.delete("None");
          if(arr.has(opt)) arr.delete(opt); else arr.add(opt);
        }
        setArr(Array.from(arr));
        updateChipSelection(el, getArr(), true);
        onFormChange();
      };
      el.appendChild(c);
    });
    updateChipSelection(el, getArr(), true);
  }

  function updateChipSelection(containerEl, value, isMulti){
    const kids = Array.from(containerEl.children);
    kids.forEach(k=>{
      const selected = isMulti
        ? safeArray(value).includes(k.textContent)
        : (value === k.textContent);
      k.classList.toggle("selected", selected);
    });
  }

  function renderDurationChips(){
    const el = $("durationChips");
    el.innerHTML = "";
    ENUMS.durationMins.forEach(mins=>{
      const c = document.createElement("div");
      c.className = "chip";
      c.textContent = mins >= 120 ? "120+ min" : `${mins} min`;
      c.onclick = ()=>{
        const start = parseDTLocal($("startAt").value);
        if(!start) return;
        const end = new Date(start.getTime() + mins*60000);
        $("endAt").value = toDTLocal(end);
        onFormChange();
      };
      el.appendChild(c);
    });
  }

  function toDTLocal(d){
    const pad = (n)=>String(n).padStart(2,"0");
    const yyyy = d.getFullYear();
    const mm = pad(d.getMonth()+1);
    const dd = pad(d.getDate());
    const hh = pad(d.getHours());
    const mi = pad(d.getMinutes());
    return `${yyyy}-${mm}-${dd}T${hh}:${mi}`;
  }

  /***********************
   * Form bind
   ***********************/
  function getFormState(){
    const start = parseDTLocal($("startAt").value);
    const ongoing = $("ongoing").value === "true";
    const end = ongoing ? null : parseDTLocal($("endAt").value);
    const severity = Number($("severity").value);

    const meds = readMedsFromUI();

    const vitals = {
      hr: numOrNull($("v_hr").value),
      spo2: numOrNull($("v_spo2").value),
      bpSys: numOrNull($("v_bpsys").value),
      bpDia: numOrNull($("v_bpdia").value)
    };
    // drop empty vitals object
    const vitalsNonEmpty = Object.values(vitals).some(v => v !== null) ? vitals : null;

    return {
      startAt: start ? start.toISOString() : null,
      ongoing,
      endAt: end ? end.toISOString() : null,
      severity,
      painType: DRAFT?.painType || "Pressure",
      location: DRAFT?.location || "Center",
      onsetActivity: DRAFT?.onsetActivity || "Rest",
      relief: safeArray(DRAFT?.relief),
      symptoms: safeArray(DRAFT?.symptoms),
      notes: ($("notes").value || "").trim(),
      vitals: vitalsNonEmpty,
      medsTaken: meds.length ? meds : null
    };
  }

  function applyFormState(s){
    $("startAt").value = s?.startAt ? toDTLocal(new Date(s.startAt)) : nowLocalDatetimeInputValue();
    $("ongoing").value = (s?.ongoing ?? true) ? "true" : "false";

    $("severity").value = String(s?.severity ?? 5);
    $("severityVal").textContent = String(s?.severity ?? 5);

    $("notes").value = s?.notes ?? "";
    $("notesCount").textContent = String(($("notes").value || "").length);

    // end time visibility
    toggleEndFields();

    if(s?.endAt && $("ongoing").value === "false"){
      $("endAt").value = toDTLocal(new Date(s.endAt));
    } else {
      $("endAt").value = "";
    }

    // chips values live on DRAFT (so we can update easily)
    DRAFT.painType = s?.painType ?? DRAFT.painType;
    DRAFT.location = s?.location ?? DRAFT.location;
    DRAFT.onsetActivity = s?.onsetActivity ?? DRAFT.onsetActivity;
    DRAFT.relief = safeArray(s?.relief);
    DRAFT.symptoms = safeArray(s?.symptoms);

    updateChipSelection($("painTypeChips"), DRAFT.painType, false);
    updateChipSelection($("locationChips"), DRAFT.location, false);
    updateChipSelection($("activityChips"), DRAFT.onsetActivity, false);
    updateChipSelection($("reliefChips"), DRAFT.relief, true);
    updateChipSelection($("symptomChips"), DRAFT.symptoms, true);

    // optional fields
    $("v_hr").value = s?.vitals?.hr ?? "";
    $("v_spo2").value = s?.vitals?.spo2 ?? "";
    $("v_bpsys").value = s?.vitals?.bpSys ?? "";
    $("v_bpdia").value = s?.vitals?.bpDia ?? "";

    // meds
    renderMedsUI(s?.medsTaken || []);
  }

  function onFormChange(){
    // update draft from form state (except chip selections already in DRAFT)
    const s = getFormState();
    // preserve chip state already kept in DRAFT
    DRAFT = {
      ...DRAFT,
      ...s,
      painType: DRAFT.painType,
      location: DRAFT.location,
      onsetActivity: DRAFT.onsetActivity,
      relief: safeArray(DRAFT.relief),
      symptoms: safeArray(DRAFT.symptoms),
      updatedAtLocal: new Date().toISOString()
    };
    scheduleDraftSave();
  }

  function toggleEndFields(){
    const ended = $("ongoing").value === "false";
    $("endAtWrap").classList.toggle("hide", !ended);
    $("durationChipsWrap").classList.toggle("hide", !ended);
    $("durationChips").classList.toggle("hide", !ended);
  }

  function numOrNull(v){
    if(v === "" || v == null) return null;
    const n = Number(v);
    return Number.isFinite(n) ? n : null;
  }

  /***********************
   * Meds UI
   ***********************/
  function renderMedsUI(meds){
    const list = $("medsList");
    list.innerHTML = "";
    meds.forEach((m, idx)=> list.appendChild(medRow(m, idx)));
    if(!meds.length){
      const empty = document.createElement("div");
      empty.className = "small muted";
      empty.textContent = "No medications recorded.";
      list.appendChild(empty);
    }
  }

  function medRow(m, idx){
    const wrap = document.createElement("div");
    wrap.className = "item";
    wrap.style.cursor = "default";

    const left = document.createElement("div");
    const name = document.createElement("input");
    name.placeholder = "Name (e.g., Antacid)";
    name.value = m.name || "";
    name.oninput = ()=>{ m.name = name.value; onFormChange(); };

    const dose = document.createElement("input");
    dose.placeholder = "Dose (optional)";
    dose.value = m.dose || "";
    dose.oninput = ()=>{ m.dose = dose.value; onFormChange(); };

    const time = document.createElement("input");
    time.type = "datetime-local";
    time.value = m.time ? toDTLocal(new Date(m.time)) : "";
    time.onchange = ()=>{ m.time = time.value ? new Date(time.value).toISOString() : null; onFormChange(); };

    const effect = document.createElement("input");
    effect.placeholder = "Effect (optional)";
    effect.value = m.effect || "";
    effect.oninput = ()=>{ m.effect = effect.value; onFormChange(); };

    left.style.flex = "1";
    left.style.display = "grid";
    left.style.gridTemplateColumns = "1fr 1fr";
    left.style.gap = "8px";
    left.appendChild(name);
    left.appendChild(dose);
    left.appendChild(time);
    left.appendChild(effect);

    const right = document.createElement("div");
    right.className = "right";
    const del = document.createElement("button");
    del.className = "danger";
    del.textContent = "Remove";
    del.onclick = ()=>{
      const meds = readMedsFromUI();
      meds.splice(idx,1);
      renderMedsUI(meds);
      onFormChange();
    };
    right.appendChild(del);

    wrap.appendChild(left);
    wrap.appendChild(right);
    return wrap;
  }

  function readMedsFromUI(){
    // This is stored in DRAFT.medsTaken, but we keep it authoritative by reading from DRAFT when possible.
    // For simplicity: rely on DRAFT.medsTaken, since our med inputs update DRAFT via onFormChange().
    const meds = safeArray(DRAFT?.medsTaken).map(x=>({
      name: (x.name || "").trim(),
      dose: (x.dose || "").trim(),
      time: x.time || null,
      effect: (x.effect || "").trim()
    })).filter(x => x.name || x.dose || x.time || x.effect);
    return meds;
  }

  /***********************
   * Episodes (local + Firestore)
   ***********************/
  function newId(){
    // local unique id (not a Firestore push id, but fine)
    return crypto.randomUUID();
  }

  async function saveEpisodeFromDraft(){
    const s = getFormState();

    // Validate minimal: startAt exists
    if(!s.startAt){
      alert("Please set a start time.");
      return;
    }

    const episode = {
      id: CURRENT_EDIT_ID || newId(),
      startAt: s.startAt,
      endAt: s.endAt,
      ongoing: s.ongoing,
      severity: s.severity,
      painType: DRAFT.painType,
      location: DRAFT.location,
      onsetActivity: DRAFT.onsetActivity,
      relief: safeArray(DRAFT.relief),
      symptoms: safeArray(DRAFT.symptoms),
      notes: s.notes || "",
      vitals: s.vitals,
      medsTaken: s.medsTaken,
      updatedAt: new Date().toISOString(),
      createdAt: CURRENT_EDIT_ID ? (getEpisodeById(CURRENT_EDIT_ID)?.createdAt || new Date().toISOString()) : new Date().toISOString(),
      _dirty: true
    };

    // Local save first
    await idbPut("episodes", episode);
    setSync(navigator.onLine ? "Saved locally" : "Offline (saved locally)");

    // Clear draft
    await discardDraft();

    // Update local cache
    await loadLocalEpisodes();
    renderAll();

    // Sync to Firestore
    if(UID){
      await upsertEpisodeRemote(episode);
    }

    // After saving, go to history
    setView("History");
  }

  function getEpisodeById(id){
    return EPISODES.find(e => e.id === id) || null;
  }

  async function upsertEpisodeRemote(ep){
    try{
      if(!navigator.onLine){
        setSync("Offline (saved locally)");
        return;
      }
      const ref = doc(db, "users", UID, "episodes", ep.id);
      await setDoc(ref, {
        ...stripLocalOnly(ep),
        ownerUid: UID,
        updatedAt: serverTimestamp(),
        createdAt: ep.createdAt ? new Date(ep.createdAt) : serverTimestamp()
      }, { merge:true });
      lastWriteError = null;
    }catch(e){
      console.error("Remote upsert failed:", e);
      lastWriteError = e;
      setSync("Sync error (saved locally)");
    }
  }

  function stripLocalOnly(ep){
    const { _dirty, ...rest } = ep;
    return rest;
  }

  // Debounced sync for edits on existing logs
  let editSyncTimer = null;
  function scheduleEditSync(ep){
    if(editSyncTimer) clearTimeout(editSyncTimer);
    editSyncTimer = setTimeout(async ()=>{
      await upsertEpisodeRemote(ep);
    }, 850);
  }

  async function openEpisodeForEdit(id){
    const ep = getEpisodeById(id);
    if(!ep) return;

    CURRENT_EDIT_ID = id;

    // Use draft as edit buffer
    DRAFT = {
      ...ep,
      painType: ep.painType || "Pressure",
      location: ep.location || "Center",
      onsetActivity: ep.onsetActivity || "Rest",
      relief: safeArray(ep.relief),
      symptoms: safeArray(ep.symptoms)
    };
    await idbPut("meta", { key: DRAFT_KEY, value: DRAFT });

    $("logTitle").textContent = "Edit episode";
    $("logSubtitle").textContent = "Auto-saved locally while you edit. Changes will sync shortly.";
    setView("Log");
    applyFormState(DRAFT);

    // Override form change behavior for edit mode: save to local episode + schedule remote sync
    // We keep using DRAFT but also mirror into episode store.
  }

  async function mirrorDraftToEpisodeAndSync(){
    if(!CURRENT_EDIT_ID) return;
    const s = getFormState();
    const ep = getEpisodeById(CURRENT_EDIT_ID);
    if(!ep) return;

    const updated = {
      ...ep,
      startAt: s.startAt,
      endAt: s.endAt,
      ongoing: s.ongoing,
      severity: s.severity,
      painType: DRAFT.painType,
      location: DRAFT.location,
      onsetActivity: DRAFT.onsetActivity,
      relief: safeArray(DRAFT.relief),
      symptoms: safeArray(DRAFT.symptoms),
      notes: s.notes || "",
      vitals: s.vitals,
      medsTaken: s.medsTaken,
      updatedAt: new Date().toISOString(),
      _dirty: true
    };

    await idbPut("episodes", updated);
    setSync(navigator.onLine ? "Saved locally" : "Offline (saved locally)");

    // Update cache in memory
    EPISODES = EPISODES.map(x => x.id === updated.id ? updated : x);
    renderAll();

    // schedule remote sync
    if(UID){
      scheduleEditSync(updated);
    }
  }

  /***********************
   * Load local data + render
   ***********************/
  async function loadLocalEpisodes(){
    EPISODES = await idbGetAllEpisodes();
    // sort desc by startAt
    EPISODES.sort((a,b)=> (b.startAt||"").localeCompare(a.startAt||""));
  }

  async function loadMeta(){
    const d = await idbGet("meta", DRAFT_KEY);
    DRAFT = d?.value || null;

    const s = await idbGet("meta", SHARE_KEY);
    SHARE_TOKEN = s?.value || null;
  }

  function renderDraftResume(){
    const box = $("resumeDraftBox");
    if(DRAFT && !CURRENT_EDIT_ID){
      // show resume only if it's a new-log draft (not editing existing)
      show(box);
      $("draftSummary").textContent = summarizeDraft(DRAFT);
      return;
    }
    hide(box);
  }

  function summarizeDraft(d){
    const sev = d?.severity ?? 5;
    const type = d?.painType ?? "—";
    const loc = d?.location ?? "—";
    const act = d?.onsetActivity ?? "—";
    const when = d?.startAt ? fmtDateTime(new Date(d.startAt)) : "—";
    return `${when} • ${sev}/10 • ${type} • ${loc} • ${act}`;
  }

  function renderKPIs(){
    const now = new Date();
    const daysAgo = (n)=> new Date(now.getTime() - n*86400000).toISOString();

    const inRange = (isoStart, days)=>{
      if(!isoStart) return false;
      if(days === "all") return true;
      return isoStart >= daysAgo(Number(days));
    };

    const last7 = EPISODES.filter(e => inRange(e.startAt, 7)).length;
    const last30 = EPISODES.filter(e => inRange(e.startAt, 30)).length;
    $("kpi7d").textContent = String(last7);
    $("kpi30d").textContent = String(last30);

    const last = EPISODES[0];
    $("kpiLast").textContent = last ? `${last.severity}/10` : "—";

    // most common activity (30d)
    const map = new Map();
    EPISODES.filter(e=> inRange(e.startAt,30)).forEach(e=>{
      const k = e.onsetActivity || "—";
      map.set(k, (map.get(k)||0)+1);
    });
    let best="—", bestN=0;
    for(const [k,v] of map.entries()){
      if(v>bestN){best=k;bestN=v;}
    }
    $("kpiCommonActivity").textContent = bestN ? `${best} (${bestN})` : "—";
  }

  function renderHistory(){
    const list = $("historyList");
    list.innerHTML = "";

    const range = $("historyRange").value;
    const sevFilter = $("historySeverity").value;

    const now = new Date();
    const cutoff = (d)=>{
      if(d==="all") return null;
      const days = Number(d);
      return new Date(now.getTime() - days*86400000).toISOString();
    };
    const minIso = cutoff(range);

    let items = EPISODES.slice();
    if(minIso) items = items.filter(e => (e.startAt||"") >= minIso);

    if(sevFilter !== "all"){
      if(sevFilter === "7+") items = items.filter(e => (e.severity ?? 0) >= 7);
      if(sevFilter === "4+") items = items.filter(e => (e.severity ?? 0) >= 4);
      if(sevFilter === "0-3") items = items.filter(e => (e.severity ?? 0) <= 3);
    }

    if(!items.length){
      const empty = document.createElement("div");
      empty.className = "muted";
      empty.textContent = "No episodes in this range.";
      list.appendChild(empty);
      return;
    }

    items.forEach(e=>{
      const item = document.createElement("div");
      item.className = "item";
      item.onclick = ()=> openEpisodeForEdit(e.id);

      const left = document.createElement("div");
      const main = document.createElement("b");
      main.textContent = `${fmtDateTime(new Date(e.startAt))} • ${e.severity}/10 • ${durationLabel(e.startAt, e.endAt, e.ongoing)}`;
      const sub = document.createElement("span");
      sub.textContent = `${e.painType || "—"} • ${e.location || "—"} • ${e.onsetActivity || "—"}`;
      left.appendChild(main);
      left.appendChild(sub);

      const right = document.createElement("div");
      right.className = "right";
      const s1 = document.createElement("span");
      const sym = safeArray(e.symptoms).filter(x=>x && x!=="None");
      s1.textContent = sym.length ? sym.slice(0,2).join(", ") + (sym.length>2 ? "…" : "") : "No symptoms";
      right.appendChild(s1);

      item.appendChild(left);
      item.appendChild(right);
      list.appendChild(item);
    });
  }

  function computeReportRows(range){
    const now = new Date();
    const minIso = (()=>{
      if(range==="all") return null;
      const days = Number(range);
      return new Date(now.getTime() - days*86400000).toISOString();
    })();

    let items = EPISODES.slice();
    if(minIso) items = items.filter(e => (e.startAt||"") >= minIso);

    // sort ascending for table readability
    items.sort((a,b)=> (a.startAt||"").localeCompare(b.startAt||""));

    const rows = items.map(e=>{
      const dt = e.startAt ? new Date(e.startAt) : null;
      return {
        dateTime: dt ? dt.toISOString() : "",
        dateTimeLabel: dt ? fmtDateTime(dt) : "—",
        severity: e.severity ?? "",
        duration: durationLabel(e.startAt, e.endAt, e.ongoing),
        activity: e.onsetActivity || "",
        typeLocation: `${e.painType || ""}${e.location ? " • " + e.location : ""}`.trim(),
        symptoms: safeArray(e.symptoms).join(", "),
        relief: safeArray(e.relief).join(", "),
        notes: (e.notes || "").trim()
      };
    });

    return rows;
  }

  function computeReportSummary(rows){
    const count = rows.length;
    if(!count) return "No episodes in the selected range.";

    // severity stats
    const sev = rows.map(r=>Number(r.severity)).filter(n=>Number.isFinite(n));
    const avg = sev.length ? (sev.reduce((a,b)=>a+b,0)/sev.length) : null;
    const max = sev.length ? Math.max(...sev) : null;

    // common activity
    const actMap = new Map();
    rows.forEach(r=>{
      const k = r.activity || "—";
      actMap.set(k, (actMap.get(k)||0)+1);
    });
    let bestAct="—", bestActN=0;
    for(const [k,v] of actMap.entries()){
      if(v>bestActN){bestAct=k;bestActN=v;}
    }

    // common symptoms (excluding None)
    const symMap = new Map();
    rows.forEach(r=>{
      r.symptoms.split(",").map(s=>s.trim()).filter(s=>s && s!=="None").forEach(s=>{
        symMap.set(s, (symMap.get(s)||0)+1);
      });
    });
    const topSyms = Array.from(symMap.entries()).sort((a,b)=>b[1]-a[1]).slice(0,3);

    const parts = [];
    parts.push(`Total episodes: ${count}.`);
    if(avg != null) parts.push(`Average severity: ${avg.toFixed(1)}/10 (max ${max}/10).`);
    if(bestActN) parts.push(`Most common onset activity: ${bestAct} (${bestActN}).`);
    if(topSyms.length) parts.push(`Most common symptoms: ${topSyms.map(([s,n])=>`${s} (${n})`).join(", ")}.`);
    return parts.join(" ");
  }

  function renderReport(){
    const range = $("exportRange").value;
    const rows = computeReportRows(range);
    const summary = computeReportSummary(rows);

    $("reportGeneratedAt").textContent = new Date().toLocaleString();
    $("reportSummary").textContent = summary;

    const tbody = $("reportTbody");
    tbody.innerHTML = "";
    rows.forEach(r=>{
      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td>${escapeHtml(r.dateTimeLabel)}</td>
        <td>${escapeHtml(String(r.severity))}</td>
        <td>${escapeHtml(r.duration)}</td>
        <td>${escapeHtml(r.activity)}</td>
        <td>${escapeHtml(r.typeLocation)}</td>
        <td>${escapeHtml(r.symptoms)}</td>
        <td>${escapeHtml(r.relief)}</td>
        <td>${escapeHtml(r.notes)}</td>
      `;
      tbody.appendChild(tr);
    });

    // Share buttons state
    updateShareUI();
  }

  function escapeHtml(s){
    return String(s ?? "").replace(/[&<>"']/g, (c)=>({
      "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
    }[c]));
  }

  function renderAll(){
    renderDraftResume();
    renderKPIs();
    renderHistory();
    renderReport();
    $("uidText").textContent = UID || "—";
  }

  /***********************
   * Share link (one active, no expiry)
   ***********************/
  function updateShareUI(){
    const has = !!SHARE_TOKEN;
    $("copyShareBtn").classList.toggle("hide", !has);
    $("revokeShareBtn").classList.toggle("hide", !has);
    $("shareLinkBox").classList.toggle("hide", !has);
    if(has){
      const link = buildShareLink(SHARE_TOKEN);
      $("shareLinkBox").textContent = link;
    }
  }

  function buildShareLink(token){
    const base = location.origin + location.pathname;
    return `${base}#share=${encodeURIComponent(token)}`;
  }

  async function createOrReplaceShareLink(){
    if(!UID){
      alert("Still starting up. Please try again in a moment.");
      return;
    }

    const range = $("exportRange").value;
    const rows = computeReportRows(range);
    const summary = computeReportSummary(rows);

    // Revoke existing first (one active link)
    if(SHARE_TOKEN){
      await revokeShareLink();
    }

    const token = crypto.randomUUID().replaceAll("-","") + crypto.randomUUID().replaceAll("-","");
    const ref = doc(db, "sharedReports", token);

    const payload = {
      ownerUid: UID,
      generatedAt: new Date().toISOString(),
      range: range,
      summary: summary,
      rows: rows
    };

    try{
      if(!navigator.onLine){
        alert("You appear offline. Connect to the internet to create the share link.");
        return;
      }
      await setDoc(ref, payload, { merge:false });

      SHARE_TOKEN = token;
      await idbPut("meta", { key: SHARE_KEY, value: SHARE_TOKEN });

      updateShareUI();
      setSync("Synced");
    }catch(e){
      console.error("Create share link failed", e);
      setSync("Sync error (saved locally)");
      alert("Could not create share link. Please try again.");
    }
  }

  async function revokeShareLink(){
    if(!SHARE_TOKEN) return;
    try{
      if(navigator.onLine){
        await deleteDoc(doc(db, "sharedReports", SHARE_TOKEN));
      }
    }catch(e){
      console.warn("Revoke remote failed (may already be deleted):", e);
    } finally {
      SHARE_TOKEN = null;
      await idbDelete("meta", SHARE_KEY);
      updateShareUI();
    }
  }

  async function copyShareLink(){
    if(!SHARE_TOKEN) return;
    const link = buildShareLink(SHARE_TOKEN);
    try{
      await navigator.clipboard.writeText(link);
      alert("Share link copied.");
    }catch{
      // fallback
      prompt("Copy this link:", link);
    }
  }

  /***********************
   * Shared view loader (public read)
   ***********************/
  async function maybeEnterShareModeFromHash(){
    const hash = location.hash || "";
    const m = hash.match(/share=([^&]+)/);
    if(!m) return false;
    const token = decodeURIComponent(m[1] || "").trim();
    if(!token) return false;

    // Share mode: hide normal nav buttons to reduce confusion
    setView("Share");
    document.querySelectorAll(".nav button").forEach(b => b.classList.add("hide"));
    $("syncPill").classList.add("hide"); // share view doesn't need sync pill

    await loadSharedReport(token);
    return true;
  }

  async function loadSharedReport(token){
    try{
      const ref = doc(db, "sharedReports", token);
      const snap = await getDoc(ref);
      if(!snap.exists()){
        show($("shareError"));
        return;
      }
      const data = snap.data();
      hide($("shareError"));

      $("shareGeneratedAt").textContent = data.generatedAt ? new Date(data.generatedAt).toLocaleString() : "—";
      $("shareSummary").textContent = data.summary || "";

      const rows = safeArray(data.rows);
      const tbody = $("shareTbody");
      tbody.innerHTML = "";
      rows.forEach(r=>{
        const tr = document.createElement("tr");
        tr.innerHTML = `
          <td>${escapeHtml(r.dateTimeLabel || "")}</td>
          <td>${escapeHtml(String(r.severity ?? ""))}</td>
          <td>${escapeHtml(r.duration || "")}</td>
          <td>${escapeHtml(r.activity || "")}</td>
          <td>${escapeHtml(r.typeLocation || "")}</td>
          <td>${escapeHtml(r.symptoms || "")}</td>
          <td>${escapeHtml(r.relief || "")}</td>
          <td>${escapeHtml(r.notes || "")}</td>
        `;
        tbody.appendChild(tr);
      });

      // download handlers for share view
      $("shareDownloadJsonBtn").onclick = ()=> downloadJSON(rows, "shared_report_rows.json");
      $("shareDownloadCsvBtn").onclick  = ()=> downloadCSV(rows, "shared_report_rows.csv");
    }catch(e){
      console.error("Load shared report failed:", e);
      show($("shareError"));
    }
  }

  /***********************
   * CSV/JSON downloads
   ***********************/
  function downloadBlob(content, filename, mime){
    const blob = new Blob([content], { type: mime });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url; a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }

  function downloadJSON(obj, filename){
    downloadBlob(JSON.stringify(obj, null, 2), filename, "application/json");
  }

  function downloadCSV(rows, filename){
    const cols = ["dateTimeLabel","severity","duration","activity","typeLocation","symptoms","relief","notes"];
    const esc = (v)=>{
      const s = String(v ?? "");
      if(/[",\n]/.test(s)) return `"${s.replaceAll('"','""')}"`;
      return s;
    };
    const header = cols.join(",");
    const lines = rows.map(r => cols.map(c => esc(r[c])).join(","));
    downloadBlob([header, ...lines].join("\n"), filename, "text/csv;charset=utf-8");
  }

  /***********************
   * Firestore sync indicator listener
   ***********************/
  function startSyncListener(){
    if(!UID) return;
    if(firestoreUnsub) firestoreUnsub();

    // Listen to last ~60 days for pending writes metadata (enough to reflect syncing)
    const now = new Date();
    const min = new Date(now.getTime() - 60*86400000);

    const qy = query(
      collection(db, "users", UID, "episodes"),
      where("startAt", ">=", min.toISOString()),
      orderBy("startAt", "desc")
    );

    firestoreUnsub = onSnapshot(qy, { includeMetadataChanges: true }, (snap)=>{
      if(!navigator.onLine){
        setSync("Offline (saved locally)");
        return;
      }
      if(snap.metadata.hasPendingWrites){
        setSync("Syncing…");
      } else {
        // only show synced if we didn't recently hit an error
        if(lastWriteError){
          setSync("Sync error (saved locally)");
        } else {
          setSync("Synced");
        }
      }
    }, (err)=>{
      console.warn("Snapshot listener error:", err);
      setSync("Sync error (saved locally)");
    });
  }

  /***********************
   * Draft lifecycle
   ***********************/
  async function discardDraft(){
    DRAFT = null;
    CURRENT_EDIT_ID = null;
    $("logTitle").textContent = "Log an episode";
    $("logSubtitle").textContent = "Auto-saved locally while you fill this in. Press “Save log” when done.";
    await idbDelete("meta", DRAFT_KEY);
    renderDraftResume();
  }

  async function startNewDraft(){
    CURRENT_EDIT_ID = null;
    DRAFT = {
      startAt: new Date().toISOString(),
      ongoing: true,
      endAt: null,
      severity: 5,
      painType: "Pressure",
      location: "Center",
      onsetActivity: "Rest",
      relief: [],
      symptoms: [],
      notes: "",
      vitals: null,
      medsTaken: []
    };
    await idbPut("meta", { key: DRAFT_KEY, value: DRAFT });
    setView("Log");
    applyFormState(DRAFT);
    renderDraftResume();
  }

  /***********************
   * Wire UI events
   ***********************/
  function wireNav(){
    $("navHome").onclick = ()=>{ location.hash=""; setView("Home"); };
    $("navLog").onclick = async ()=>{ location.hash=""; if(DRAFT) { setView("Log"); applyFormState(DRAFT); } else await startNewDraft(); };
    $("navHistory").onclick = ()=>{ location.hash=""; setView("History"); renderHistory(); };
    $("navExport").onclick = ()=>{ location.hash=""; setView("Export"); renderReport(); };
    $("navSettings").onclick = ()=>{ location.hash=""; setView("Settings"); };

    $("homeLogNow").onclick = async ()=>{ if(DRAFT) { setView("Log"); applyFormState(DRAFT); } else await startNewDraft(); };
    $("homeHistory").onclick = ()=> setView("History");
    $("homeExport").onclick = ()=> setView("Export");

    $("resumeDraftBtn").onclick = ()=>{ setView("Log"); applyFormState(DRAFT); };
    $("discardDraftBtn").onclick = async ()=>{ await discardDraft(); renderAll(); };

    $("discardDraftBtn2").onclick = async ()=>{ await discardDraft(); renderAll(); };

    $("newDraftBtn").onclick = async ()=>{
      if(confirm("Start a new draft? This will replace the current draft (the current one is still auto-saved if you cancel).")){
        await startNewDraft();
      }
    };

    $("backHomeBtn").onclick = ()=> setView("Home");

    // form events
    $("startAt").onchange = onFormChange;
    $("ongoing").onchange = ()=>{ toggleEndFields(); onFormChange(); };
    $("endAt").onchange = onFormChange;

    $("severity").oninput = ()=>{
      $("severityVal").textContent = $("severity").value;
      onFormChange();
    };

    $("notes").oninput = ()=>{
      $("notesCount").textContent = String(($("notes").value||"").length);
      onFormChange();
    };

    ["v_hr","v_spo2","v_bpsys","v_bpdia"].forEach(id=>{
      $(id).oninput = onFormChange;
    });

    $("addMedBtn").onclick = ()=>{
      const meds = safeArray(DRAFT?.medsTaken);
      meds.push({ name:"", dose:"", time:null, effect:"" });
      DRAFT.medsTaken = meds;
      renderMedsUI(meds);
      onFormChange();
    };

    $("saveLogBtn").onclick = async ()=>{
      if(CURRENT_EDIT_ID){
        // editing existing: do a final mirror + immediate remote sync
        await mirrorDraftToEpisodeAndSync();
        const ep = getEpisodeById(CURRENT_EDIT_ID);
        if(ep && UID) await upsertEpisodeRemote(ep);
        await discardDraft();
        setView("History");
      } else {
        await saveEpisodeFromDraft();
      }
    };

    // history filters
    $("historyRange").onchange = renderHistory;
    $("historySeverity").onchange = renderHistory;

    // export buttons
    $("refreshReportBtn").onclick = renderReport;
    $("printBtn").onclick = ()=> window.print();
    $("downloadJsonBtn").onclick = ()=>{
      const rows = computeReportRows($("exportRange").value);
      downloadJSON(rows, "chest_pain_report_rows.json");
    };
    $("downloadCsvBtn").onclick = ()=>{
      const rows = computeReportRows($("exportRange").value);
      downloadCSV(rows, "chest_pain_report_rows.csv");
    };
    $("exportRange").onchange = renderReport;

    // share
    $("createShareBtn").onclick = createOrReplaceShareLink;
    $("copyShareBtn").onclick = copyShareLink;
    $("revokeShareBtn").onclick = async ()=>{
      if(confirm("Revoke the share link? Anyone with the link will lose access.")){
        await revokeShareLink();
      }
    };

    // settings export all
    $("exportAllJsonBtn").onclick = ()=> downloadJSON(EPISODES, "all_episodes.json");
    $("exportAllCsvBtn").onclick = ()=>{
      // reuse report format but for all episodes
      const rows = EPISODES.map(e => ({
        dateTimeLabel: e.startAt ? fmtDateTime(new Date(e.startAt)) : "",
        severity: e.severity ?? "",
        duration: durationLabel(e.startAt, e.endAt, e.ongoing),
        activity: e.onsetActivity || "",
        typeLocation: `${e.painType || ""}${e.location ? " • " + e.location : ""}`.trim(),
        symptoms: safeArray(e.symptoms).join(", "),
        relief: safeArray(e.relief).join(", "),
        notes: (e.notes || "").trim()
      }));
      downloadCSV(rows, "all_episodes.csv");
    };

    $("clearAllBtn").onclick = async ()=>{
      if(!confirm("This will delete ALL episodes locally and in Firebase for this device. Continue?")) return;
      await clearAllData();
    };

    // share view print
    $("sharePrintBtn").onclick = ()=> window.print();

    // hash routing
    window.addEventListener("hashchange", async ()=>{
      const inShare = await maybeEnterShareModeFromHash();
      if(!inShare){
        // restore normal view if user removes hash
        document.querySelectorAll(".nav button").forEach(b => b.classList.remove("hide"));
        $("syncPill").classList.remove("hide");
        setView("Home");
      }
    });
  }

  /***********************
   * Clear all data
   ***********************/
  async function clearAllData(){
    // local
    try{
      const dbi = await idbOpen();
      await new Promise((resolve,reject)=>{
        const tx = dbi.transaction(["episodes","meta"], "readwrite");
        tx.objectStore("episodes").clear();
        tx.objectStore("meta").clear();
        tx.oncomplete = ()=> resolve(true);
        tx.onerror = ()=> reject(tx.error);
      });
    }catch(e){
      console.warn("Local clear failed", e);
    }

    // remote (best effort)
    if(UID && navigator.onLine){
      try{
        // delete shared report if exists
        if(SHARE_TOKEN){
          await deleteDoc(doc(db, "sharedReports", SHARE_TOKEN));
        }

        // delete episodes by listing (fine for small datasets; for very large, we'd use a Cloud Function)
        const qy = query(collection(db, "users", UID, "episodes"));
        const snaps = await getDocs(qy);
        for(const s of snaps.docs){
          await deleteDoc(s.ref);
        }
      }catch(e){
        console.warn("Remote clear failed", e);
      }
    }

    // reset in-memory
    EPISODES = [];
    DRAFT = null;
    SHARE_TOKEN = null;
    CURRENT_EDIT_ID = null;

    setSync("Synced");
    renderAll();
    setView("Home");
    alert("All data cleared.");
  }

  /***********************
   * Initialize
   ***********************/
  function initChips(){
    // initialize DRAFT defaults so chip handlers can update DRAFT
    DRAFT = DRAFT || {
      painType:"Pressure",
      location:"Center",
      onsetActivity:"Rest",
      relief:[],
      symptoms:[]
    };

    renderSingleSelectChips("painTypeChips", ENUMS.painType, ()=>DRAFT.painType, (v)=>{ DRAFT.painType=v; });
    renderSingleSelectChips("locationChips", ENUMS.location, ()=>DRAFT.location, (v)=>{ DRAFT.location=v; });
    renderSingleSelectChips("activityChips", ENUMS.activity, ()=>DRAFT.onsetActivity, (v)=>{ DRAFT.onsetActivity=v; });
    renderMultiSelectChips("reliefChips", ENUMS.relief, ()=>safeArray(DRAFT.relief), (arr)=>{ DRAFT.relief=arr; });
    renderMultiSelectChips("symptomChips", ENUMS.symptoms, ()=>safeArray(DRAFT.symptoms), (arr)=>{ DRAFT.symptoms=arr; });
    renderDurationChips();
  }

  async function bootstrap(){
    setSync("Starting…");

    // If share mode, we can skip auth entirely, but it's harmless to attempt.
    const inShare = await maybeEnterShareModeFromHash();
    if(inShare){
      // still initialize network status indicators (not shown)
      return;
    }

    // Start invisible anonymous auth
    try{
      await signInAnonymously(auth);
    }catch(e){
      console.error("Anonymous auth failed:", e);
      setSync("Sync error (saved locally)");
    }

    onAuthStateChanged(auth, async (user)=>{
      if(user){
        UID = user.uid;
        $("uidText").textContent = UID;
        startSyncListener();
      }

      // Load local data
      await loadMeta();
      await loadLocalEpisodes();

      // Render chips + restore draft if present
      initChips();
      if(DRAFT){
        // ensure defaults exist
        DRAFT.painType = DRAFT.painType || "Pressure";
        DRAFT.location = DRAFT.location || "Center";
        DRAFT.onsetActivity = DRAFT.onsetActivity || "Rest";
        DRAFT.relief = safeArray(DRAFT.relief);
        DRAFT.symptoms = safeArray(DRAFT.symptoms);
      }

      renderAll();

      // show appropriate sync status
      if(!navigator.onLine){
        setSync("Offline (saved locally)");
      } else {
        setSync("Synced");
      }
    });

    // Online/offline indicator
    window.addEventListener("online", ()=> setSync("Synced"));
    window.addEventListener("offline", ()=> setSync("Offline (saved locally)"));

    // Form auto-save behavior:
    // When editing existing episodes, we also mirror into episode store and schedule remote sync
    const originalOnFormChange = onFormChange;
    window.onFormChange = async ()=>{
      originalOnFormChange();
      if(CURRENT_EDIT_ID){
        await mirrorDraftToEpisodeAndSync();
      }
    };
  }

  // Override onFormChange hook used by chip + input handlers
  // (We keep a function name and route to window.onFormChange)
  const _onFormChange = onFormChange;
  function onFormChange(){
    if(typeof window.onFormChange === "function"){
      window.onFormChange = window.onFormChange; // no-op to keep reference
    }
    _onFormChange();
    if(CURRENT_EDIT_ID){
      mirrorDraftToEpisodeAndSync();
    }
  }

  wireNav();
  await bootstrap();

  // If there's a draft, ensure UI reflects it if user goes to log view
  if(DRAFT && !CURRENT_EDIT_ID){
    // Keep draft in Home; do nothing
  } else if(!DRAFT){
    // no draft
  }

</script>
</body>
</html>

